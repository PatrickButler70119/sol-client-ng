<template>
  <l-layer-group v-if="this.race.loaded">
    <l-rectangle
       :bounds="this.raceBoundary"
       :fill="false"
       :weight="2"
       color="magenta"
    />
    <l-circle-marker
      v-for="(waypoint, index) in this.raceRoute"
      :key="index"
      :latLng="waypoint.latLng"
      :fillColor="wpColor"
      :radius="waypoint.radius"
      :color="wpColor"
      :fillOpacity="1"
    >
      <l-tooltip
        :options="wpTooltipOptions"
      >
        <span v-html="waypoint.name"/><br>
        {{waypoint.info}}
      </l-tooltip>
    </l-circle-marker>
    <l-circle-marker
      v-for="(endpoint, index) in this.finishLine"
      :key="'f' + index"
      :lat-lng="endpoint"
      :fillColor="wpColor"
      :radius="finishPointRadius"
      :color="wpColor"
      :fillOpacity="1"
    />
    <l-polyline
      :lat-lngs="finishLine"
      :fill="false"
      :color="wpColor"
      :weight="1"
    />

  </l-layer-group>
</template>

<script>
import { mapState } from 'vuex';
import { LLayerGroup, LCircleMarker, LPolyline, LRectangle, LTooltip } from 'vue2-leaflet'
import { latLngAddOffset } from '../../lib/utils.js';

export default {
  name: 'Map',
  components: {
    'l-layer-group': LLayerGroup,
    'l-circle-marker': LCircleMarker,
    'l-polyline': LPolyline,
    'l-rectangle': LRectangle,
    'l-tooltip': LTooltip,
  },

  props: {
    map: {
      type: Object,
      required: true,
    },
    lngOffset: {
      type: Number,
      default: 0,
    }
  },
  data () {
    return {
      wpColor: "red",
      wpTooltipOptions: {
        permanent: true,
        direction: 'right',
        className: 'wp-tooltip',
      },
      finishPointRadius: 1,
    }
  },

  computed: {
    raceBoundary () {
      return [latLngAddOffset(this.race.boundary[0], this.lngOffset),
              latLngAddOffset(this.race.boundary[1], this.lngOffset)];
    },
    raceRoute () {
      let route = [];

      for (let i = 0; i < this.race.route.length; i++) {
        route.push({
          latLng: latLngAddOffset(this.race.route[i].latLng, this.lngOffset),
          name: this.race.route[i].name,
          radius: (i !== this.race.route.length - 1) ? 2 : this.finishPointRadius,
          info: this.markInfoText(i),
        });
      }
      return route;
    },
    finishLine () {
      return this.race.finish.map(pt => latLngAddOffset(pt, this.lngOffset));
    },
    ...mapState({
      race: state => state.race,
      lastRoundedMark: state => state.boat.current_leg,
      finishTime: state => state.boat.finish_time,
    }),
  },

  methods: {
    markInfoText (mark) {
      if (mark === 0) {
        return "(Start)";
      }

      if (mark < this.race.route.length - 1) {
        if (mark <= this.lastRoundedMark) {
          return "Rounded.";
        }

        return "Leave to " + this.race.route[mark].side;
      }

      return this.finishTime === null ? "Cross line to Finish" : "Finished.";
    },
  },
}
</script>
